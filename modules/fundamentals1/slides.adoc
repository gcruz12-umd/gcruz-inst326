= Into the weeds: Python fundamentals
:imagesdir: images
:docinfo: shared
:revealjsdir: https://cdn.jsdelivr.net/npm/reveal.js
:source-highlighter: highlightjs
:highlightjsdir: https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1
:highlightjs-theme: https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/base16/tomorrow-night.min.css
:customcss: ../../css/default.css
:revealjs_theme: white
:revealjs_width: 1400
:revealjs_height: 800
:revealjs_slideNumber: true
:revealjs_transition: slide
:revealjs_transitionSpeed: default
:title-slide-background-image: 1024px-In_the_corn_field.jpg

== Statements

A *statement* is a complete Python instruction

[.notes]
--
Start by asking students: "What do you think makes up a Python program?" Guide them toward the idea that programs are made of instructions.

A statement is the fundamental building block of Python programs. Every line of code that does something is a statement. We'll see there are two main types: simple and compound.
--

=== Two Kinds of Statements

*Simple* — one instruction

*Compound* — contains other statements

[.notes]
--
Simple statements are single-line instructions that do one thing. Compound statements are more complex structures that contain other statements inside them.

Think of it like sentences vs. paragraphs. A simple statement is a sentence. A compound statement is a paragraph that contains multiple sentences working together.
--

=== Simple Statements

[source,python]
x = 0

[source,python]
return True

[source,python]
print("Hello")

[.notes]
--
Walk through each example:

1. `x = 0` — This is an assignment statement. It creates a variable x and gives it the value 0.

2. `return True` — This returns a value from a function. We'll cover functions later.

3. `print("Hello")` — This calls the print function to display text.

Each of these is complete on its own line. They don't need anything else to work.

You can also mention `continue` as another simple statement example.
--

=== Compound Statements

[source,python]
----
for word in wordlist:
    print(word)
    first_letter = word[0]
----

[source,python]
----
if score >= 5:
    print("You win!")
else:
    print("Better luck next time.")
----

[.notes]
--
Compound statements contain other statements inside them. Notice the colon at the end of the first line and the indentation of the lines that follow.

For the `for` loop: This iterates through a list of words. The two indented lines are the "body" of the loop—they run for each word.

For the `if` statement: This checks a condition and runs different code depending on whether it's true or false.

Key observation: The body is always indented. This is how Python knows which statements belong inside the compound statement.
--

=== Anatomy of a Compound Statement

image::anatomy_of_complex_statement.png[ComplexStatement]

[.notes]
--
Point to each part of the diagram as you explain:

CLAUSE: A complete unit within a compound statement. An if/elif/else has multiple clauses.

HEADER: The first line of a clause. It always ends with a colon. Contains keywords like `if`, `for`, `while`, `def`, etc.

BODY: The indented code that belongs to a clause. Can contain simple statements, other compound statements, or both.

Critical rule: The body MUST be indented relative to the header. Python uses indentation to determine structure, unlike languages that use braces.

Common student mistake: Forgetting the colon at the end of the header. Python will give a syntax error.
--

=== Statements: Summary

* A statement is a complete Python instruction
* *Simple statements* — individual instructions
* *Compound statements* — contain other statements
* Bodies are always indented

[.notes]
--
Quick recap before moving on. Ask students to give you an example of each type.

Transition: "Now let's look at what goes inside statements—expressions."
--

== Expressions

An *expression* is code that evaluates to a value

[.notes]
--
Key distinction: Statements DO something. Expressions PRODUCE something (a value).

Anywhere Python expects a value, you can put an expression. This is incredibly powerful—it means you can nest expressions inside other expressions.

Important: Any expression that stands alone on a line is also a statement (called an "expression statement").
--

=== Common Expression Types

*Literals* — `5`, `"hi"`, `True`

*Variables* — evaluate to their current value

*Function calls* — `abs(-4)`, `round(10.6)`

[.notes]
--
LITERALS: These are values written directly in your code. The number 5 is an expression that evaluates to... 5. The string "hi" evaluates to the string "hi".

VARIABLES: When Python sees a variable name, it looks up the value and uses that. So if x equals 10, the expression `x` evaluates to 10.

FUNCTION CALLS: These run a function and evaluate to whatever the function returns. `abs(-4)` evaluates to 4. `round(10.6)` evaluates to 11.

You can combine these with operators to make more complex expressions.
--

=== Operators

[cols="1,1,1", frame=none, grid=none]
|===
| *Arithmetic*
| *Comparison*
| *Logical*

| `+` `-` `*`
| `==` `!=`
| `not`

| `/` `//` `%`
| `>` `<`
| `and`

| `**`
| `>=` `\<=`
| `or`
|===

Also: `in` (membership), `is` (identity)

[.notes]
--
ARITHMETIC: Standard math operators. Note there are THREE division operators—we'll cover those next.

COMPARISON: These compare values and return True or False. Double equals for equality (single equals is assignment!).

LOGICAL: For combining boolean values. `not` flips True/False. `and` requires both to be true. `or` requires at least one to be true.

MEMBERSHIP: `in` checks if something is inside a collection. Very useful for strings and lists.

IDENTITY: `is` checks if two things are the exact same object in memory. Different from `==` which checks if values are equal.
--

=== Division Operators

`/` — floating-point division → `5 / 4` is `1.25`

`//` — floor division → `5 // 4` is `1`

`%` — modulo (remainder) → `5 % 4` is `1`

[.notes]
--
This trips up students constantly. Take time here.

FLOATING-POINT DIVISION (`/`): Always gives you a decimal result, even if it divides evenly. `4 / 2` gives `2.0`, not `2`.

FLOOR DIVISION (`//`): Rounds DOWN to the nearest integer. For positive numbers, it's like truncating. But `-5 // 4` is `-2`, not `-1`! It rounds toward negative infinity.

MODULO (`%`): Gives the remainder. Super useful for:
- Testing if a number is even: `x % 2 == 0`
- Wrapping around (like clock arithmetic)
- Extracting digits from numbers

Common student confusion: They use `/` when they want `//`, then wonder why they're getting floats.

Mention: Floating-point math can be imprecise due to how computers store decimals. `0.1 + 0.2` is not exactly `0.3`.
--

=== Parentheses

Used for grouping, just like algebra

[source,python]
----
(  3 * x**3
 + 4 * x**2
 - 2 * x
 + 1)
----

[.notes]
--
Parentheses work exactly like in math class—they force certain operations to happen first.

BONUS: A parenthesized expression can span multiple lines! This is really useful for long calculations or conditions. No backslashes needed.

This is cleaner than using backslashes for line continuation.

Operator precedence exists (PEMDAS-like), but when in doubt, use parentheses to make your intent clear.
--

=== Expressions: Summary

* Expressions evaluate to values
* Types: literals, variables, function calls
* Operators combine expressions
* Division: `/` vs `//` vs `%`
* Parentheses for grouping

[.notes]
--
Transition: "Now that we know about expressions, let's talk about storing values in variables."
--

== Variables

Variables are *labels* attached to values

[.notes]
--
Important mental model: Variables in Python are NOT boxes that hold values. They're labels or name tags attached to values.

This means multiple variables can point to the same value. If you do `a = [1,2,3]` and then `b = a`, both variables point to the SAME list. Changing the list through `a` affects what you see through `b`.

This is different from languages like C where variables are memory locations.
--

=== Variable Naming Rules

* Letters, numbers, underscores only
* Cannot start with a number
* Cannot use keywords (`if`, `return`, `def`)
* Avoid function names (`print`, `list`, `round`)
* Convention: use lowercase

[.notes]
--
CANNOT START WITH NUMBER: `2fast` is invalid, but `fast2` is fine.

KEYWORDS: Python reserves certain words. You'll get a syntax error if you try to use them as variable names.

FUNCTION NAMES: You CAN use these, but you'll break the function! If you do `print = 5`, you can no longer use the print function. Very common beginner mistake.

CONVENTION: Python uses `snake_case` for variables (lowercase with underscores). `CamelCase` is reserved for class names. Following conventions makes your code readable to other Python programmers.

Good names: `user_age`, `total_score`, `first_name`
Bad names: `x`, `data`, `temp` (unless truly temporary)
--

=== Variable Assignment

[source,python]
name = "Gina"

[source,python]
area = width * height

[source,python]
nearest_int = round(5.3)

[.notes]
--
The pattern: variable = expression

Python evaluates the RIGHT side first, then attaches the label to that value.

Example 1: Creates a string "Gina" and labels it `name`.

Example 2: Multiplies width by height, then labels the result `area`. Note: width and height must already exist!

Example 3: Calls round(5.3), which returns 5, then labels that 5 as `nearest_int`.

IMPORTANT: Assignment statements are NOT expressions. You cannot do `print(x = 5)` like in some other languages. (Python 3.8+ has the walrus operator `:=` for this, but that's advanced.)
--

=== Augmented Assignment

Instead of: `x = x + 1`

Write: `x += 1`

Available: `+=` `-=` `*=` `/=` `//=` `%=` `**=`

[.notes]
--
This is syntactic sugar for a very common pattern: update a variable based on its current value.

`x += 1` means "take the current value of x, add 1, and store it back in x."

All the arithmetic operators have augmented versions. You'll use `+=` most often.

Common use cases:
- Counting: `count += 1`
- Accumulating sums: `total += price`
- Building strings: `message += " more text"`

Note: These are still statements, not expressions.
--

=== Variables: Summary

* Variables are labels attached to values
* Assignment: `variable = expression`
* Augmented assignment: `+=`, `-=`, etc.

[.notes]
--
Transition: "Now let's look at how to make decisions in our code."
--

== Conditional Statements

[source,python]
----
if temp <= 0:
    water_state = "ice"
elif temp <= 100:
    water_state = "water"
else:
    water_state = "steam"
----

[.notes]
--
Conditional statements let your program make decisions.

Walk through the example: We're determining the state of water based on temperature (in Celsius).

- If temp is 0 or below → ice
- Otherwise, if temp is 100 or below → water
- Otherwise → steam

Only ONE of these three branches will execute. Once a condition is true, Python runs that branch and skips the rest.
--

=== Structure

* `if` — required, comes first
* `elif` — zero or more
* `else` — zero or one, comes last

Only *one* branch executes!

[.notes]
--
IF: Always required. Must have at least one `if`.

ELIF: "Else if" — only checked if previous conditions were false. You can have as many as you need, or none at all.

ELSE: Catches everything that didn't match above. No condition needed—it's the default. Optional.

Critical point: At most ONE branch executes. As soon as Python finds a true condition, it runs that branch and skips checking the rest. This is why order matters!
--

=== `elif` vs `if`

[source,python]
----
# Using elif
if temp <= 0:
    water_state = "ice"
elif temp <= 100:
    water_state = "water"
----

[source,python]
----
# Using if
if temp <= 0:
    water_state = "ice"
if temp <= 100:
    water_state = "water"
----

What happens when temp is -10?

[.notes]
--
This is a CRITICAL distinction that confuses students.

WITH ELIF: If temp is -10, the first condition is true, so water_state becomes "ice". The elif is SKIPPED because we already found a match. Final answer: "ice"

WITH SEPARATE IFS: If temp is -10, the first if is true, so water_state becomes "ice". But then Python checks the SECOND if independently. Is -10 <= 100? Yes! So water_state gets overwritten to "water". Final answer: "water" — WRONG!

Rule: Use `elif` when conditions are mutually exclusive and you only want one to run. Use separate `if` statements when you want to check each condition independently.

Test the students: What happens with temp = 15? With temp = 120?
--

=== Boolean Contexts

Conditions are *Boolean contexts*

Most values are "truthy"

Falsy values: `0`, `0.0`, empty collections, `None`

[.notes]
--
When Python needs a True/False answer, it converts values automatically.

TRUTHY: Most things. Any non-zero number, any non-empty string, any non-empty list, etc.

FALSY (memorize these):
- Zero (integer 0 or float 0.0)
- Empty string ""
- Empty list []
- Empty dictionary {}
- None
- False (obviously)

This is useful! Instead of `if len(my_list) > 0:` you can just write `if my_list:`

Example:
```python
answer = input("Enter something: ")
if answer:    # True if they typed anything
    print("You entered:", answer)
else:
    print("You didn't enter anything")
```
--

=== Conditional Expressions

[source,python]
status = "minor" if age < 18 else "adult"

[.notes]
--
This is Python's ternary operator—a one-liner for simple if/else.

Pattern: `value_if_true if condition else value_if_false`

Read it as: "status equals 'minor' IF age is less than 18, ELSE 'adult'"

The else part is REQUIRED (unlike in conditional statements).

Use these for simple cases. If your logic is complex, use a regular if/else statement—readability matters more than brevity.

You can chain them: 
```python
water_state = "ice" if temp <= 0 else "water" if temp <= 100 else "steam"
```
But this gets hard to read quickly.
--

=== Conditionals: Summary

* Conditional *statements* execute code
* Conditional *expressions* produce values
* Conditions are Boolean contexts
* Use `elif` for mutually exclusive conditions

[.notes]
--
Transition: "What if we want to repeat code multiple times? That's where loops come in."
--

== Loops

Loops let us repeat instructions

*for* — iterations known in advance

*while* — iterations not known in advance

[.notes]
--
Both types are compound statements with headers and bodies.

FOR loops: Use when you know how many times to iterate, or when you're iterating over a collection.

WHILE loops: Use when you need to repeat until some condition changes, and you don't know in advance when that will be.
--

=== `for` Loops

[source,python]
----
for i in range(1, 11):
    t += i
    print(t)
----

[.notes]
--
Pattern: `for variable in iterable:`

ITERABLE: Something you can iterate over—a list, string, range, file, etc.

ITERATION VARIABLE: Created by the for loop. Takes on each value from the iterable in turn. In this example, i will be 1, then 2, then 3... up to 10.

Note: `range(1, 11)` gives you 1 through 10. The end value is exclusive! This trips up students.

The body runs once for each item. Here we're calculating triangular numbers (1, 3, 6, 10, 15...).

Common uses:
- `for item in my_list:` — process each item
- `for char in my_string:` — process each character
- `for i in range(n):` — repeat n times
--

=== `while` Loops

[source,python]
----
n = 1
while n < 1000:
    n *= 3
print(n)
----

[.notes]
--
Pattern: `while condition:`

The loop keeps running AS LONG AS the condition is true. When it becomes false, the loop ends.

DANGER: If the condition never becomes false, you have an infinite loop! Always make sure something in the body can change the condition.

This example finds the first power of 3 greater than 1000. We start at 1 and keep multiplying by 3 until we exceed 1000.

Trace through: n=1, n=3, n=9, n=27, n=81, n=243, n=729, n=2187 (stops here because 2187 >= 1000).

Use while when:
- Waiting for user to enter valid input
- Reading until end of file
- Searching for something
- Any situation where you don't know the count beforehand
--

=== `while True:`

Guarantees at least one iteration

[source,python]
----
while True:
    response = input("Choose 'a' or 'b': ")
    if response in ['a', 'b']:
        return response
    print("Invalid choice.")
----

[.notes]
--
`while True` creates an intentionally infinite loop. You MUST have a `break` or `return` inside to exit!

Why use it? When you want the body to run AT LEAST ONCE before checking a condition.

This pattern is called a "do-while" in other languages. Python doesn't have do-while, so we use `while True` with a break/return.

Perfect for input validation: Ask for input, check if it's valid, return if yes, otherwise show error and ask again.

Common mistake: Forgetting the exit condition and creating an actual infinite loop. Always have a clear path out!
--

=== Loop Control

*continue* — skip to next iteration

*break* — exit the loop entirely

*return* — exit loop and function

[.notes]
--
CONTINUE: Stops the current iteration and jumps back to the top of the loop. For `for` loops, moves to the next item. For `while` loops, re-checks the condition.

BREAK: Immediately exits the loop. Code continues after the loop.

RETURN: Exits both the loop AND the function it's in. Only works inside functions.

Use cases:
- Continue: Skip items that don't meet criteria
- Break: Found what you're looking for, no need to keep searching
- Return: Ready to give back a result
--

=== Loop Control Example

[source,python]
----
data = list()
for line in f:
    line = line.strip()
    if line[0] == "#":
        continue       # skip comments
    if line == "----":
        break          # stop at separator
    data.append(line)
----

[.notes]
--
Walk through this file-reading example:

We're processing a file with specific rules:
1. Lines starting with # are comments—skip them
2. A line of "----" means stop reading
3. Everything else gets added to our list

CONTINUE: When we hit a comment line, we don't want to add it to data. `continue` skips the rest of the loop body and moves to the next line.

BREAK: When we hit the separator, we're done. `break` exits the loop entirely—we don't care about lines after this.

Without continue/break, we'd need nested if statements and flag variables. This is cleaner.
--

=== Loops: Summary

* `for` — known number of iterations
* `while` — repeat until condition is false
* `while True` — at least one iteration
* Control: `continue`, `break`, `return`

[.notes]
--
Transition: "Now let's package our code into reusable units—functions."
--

== Functions

Reusable instruction sequences

* Take input (arguments)
* Return output (return value)

[.notes]
--
Functions are the fundamental unit of code organization. They let you:
- Write code once, use it many times
- Break complex problems into smaller pieces
- Test pieces independently
- Make code readable by giving names to operations

Think of a function like a machine: you put things in (arguments), something happens inside, and you get something out (return value).
--

=== Built-in Functions

`print()` — display output

`abs()` — absolute value

`round()` — round a number

`int()`, `float()`, `str()` — type conversion

[.notes]
--
Python comes with many built-in functions. These are always available.

PRINT: Display to console. Returns None.

ABS: Absolute value. `abs(-5)` returns `5`.

ROUND: Round to nearest integer (or specified decimals). `round(3.7)` returns `4`. `round(3.14159, 2)` returns `3.14`.

TYPE CONVERSIONS:
- `int("42")` returns `42`
- `float("3.14")` returns `3.14`
- `str(42)` returns `"42"`

These will raise errors if the conversion isn't possible: `int("hello")` raises ValueError.
--

=== Calling Functions

[source,python]
print()              # no arguments

[source,python]
x = abs(-10)         # one argument

[source,python]
n = round(14.723, 2) # two arguments

[.notes]
--
Every function call has parentheses, even if there are no arguments.

The value inside the parentheses (the argument) can be any expression. So `abs(-10)` works, but so does `abs(x)` or `abs(y - z)`.

Function calls ARE expressions—they evaluate to the return value. That's why we can assign `abs(-10)` to `x`.

If a function doesn't explicitly return something, it returns `None`.
--

=== Positional vs Keyword Arguments

[source,python]
print("Hello", "world!", sep="::", end="\n")

*Positional:* `"Hello"`, `"world!"`

*Keyword:* `sep="::"`, `end="\n"`

[.notes]
--
POSITIONAL: Matched to parameters by position (first argument to first parameter, etc.). Order matters!

KEYWORD: Matched by name. Order doesn't matter among keyword arguments.

Rules:
1. Positional arguments must come BEFORE keyword arguments
2. You can't have positional arguments after keyword arguments

This print call outputs: `Hello::world!` followed by a newline and dashes.

Use keyword arguments for optional parameters or when the meaning isn't obvious from position.
--

=== Why Write Functions?

* Break problems into discrete steps
* Make code easier to read
* Make code easier to test
* Enable code reuse

[.notes]
--
Functions are not just about avoiding repetition (though that's important).

PROBLEM DECOMPOSITION: Complex problems become manageable when broken into small functions.

READABILITY: `calculate_tax(income)` is clearer than 20 lines of tax calculation inline.

TESTING: You can test small functions in isolation. If each function works, the whole program is more likely to work.

REUSE: Write once, use many times. Even use in other projects.

Rule of thumb: If you're copying and pasting code, you probably need a function.
--

=== Defining Functions

[source,python]
----
def dist(x1, y1, x2, y2):
    """ Calculate Euclidean distance
    between (x1, y1) and (x2, y2). """
    return ((x1-x2)**2 + (y1-y2)**2)**0.5
----

[.notes]
--
Pattern: `def function_name(parameters):`

DEF: Keyword that starts a function definition.

FUNCTION NAME: Same rules as variable names. Should describe what the function does.

PARAMETERS: Variables that receive the arguments. Separated by commas if multiple.

DOCSTRING: A string right after the header that describes the function. Triple quotes for multi-line. This is documentation!

BODY: The code that runs when the function is called.

RETURN: Specifies what value the function evaluates to. If you don't return anything (or just `return` with no value), the function returns `None`.
--

=== Variable Scope

*Global* — defined outside functions, accessible everywhere

*Local* — defined inside functions, only accessible there

*Local variables are preferred!*

[.notes]
--
SCOPE: Where a variable can be accessed.

GLOBAL VARIABLES: Defined at the top level of your script. Can be read anywhere. But modifying them from inside a function requires the `global` keyword.

Problems with globals:
- Functions aren't self-contained
- Hard to track what's changing the variable
- Leads to subtle bugs

LOCAL VARIABLES: Defined inside a function (including parameters). Created when function runs, destroyed when function ends.

Benefits of locals:
- Function is self-contained
- No outside interference
- Easier to test and debug

Best practice: Pass values IN through parameters, get values OUT through return. Avoid globals.
--

=== Required vs Optional Parameters

[source,python]
----
def get_pace(dist, time, dist_unit="mile", time_unit="minute"):
    """ Calculate pace given distance and time. """
    print(time/dist, time_unit + "s per", dist_unit)
----

[.notes]
--
REQUIRED: Just a name. Must be provided when calling. Here: `dist` and `time`.

OPTIONAL: Have a default value using `=`. Can be omitted when calling. Here: `dist_unit` and `time_unit`.

Rules:
- Required parameters must come BEFORE optional parameters
- Avoid mutable defaults like lists or dictionaries (they're shared between calls!)

Calling this function:
- `get_pace(3, 54)` — uses defaults: "minutes per mile"
- `get_pace(6, 0.9, time_unit="hour")` — override one default
- `get_pace(16, 0.8, dist_unit="km", time_unit="hour")` — override both
--

=== `return` vs `print()`

*return* — defines the function's output value

*print()* — displays text to the user

[.notes]
--
Students confuse these constantly!

RETURN:
- Sends a value back to the calling code
- The function call expression equals this value
- You can use the returned value in further calculations
- Nothing visible happens on screen

PRINT:
- Displays text on the console
- Returns None
- The displayed text cannot be used by your program
- Only for human eyes

Example:
```python
def add(a, b):
    return a + b  # Good: result can be used

result = add(3, 4)  # result is 7
```

vs.

```python
def add(a, b):
    print(a + b)  # Bad: just displays, can't use result

result = add(3, 4)  # result is None!
```

Rule: Functions should RETURN results. Print them separately if needed.
--

=== Can You Read This?

[source,python]
----
def f(n):
    if not isinstance(n, int):
        raise TypeError("n must be an integer")
    if n < 2:
        raise ValueError("n must be at least 2")
    fs = []
    for i in range(2, int(n**0.5)+1):
        while n % i == 0:
            fs.append(i)
            n //= i
    if n != 1:
        fs.append(n)
    return fs
----

[.notes]
--
Show this slide briefly, then ask: "What does this function do?"

Give students 30 seconds to think about it.

Problems:
- Cryptic function name `f`
- Cryptic variable name `fs`
- No docstring
- No comments
- Algorithm is not obvious

This is REAL code that a student had to decipher at a research job. Don't write code like this!

Now show the next slide with the improved version...
--

=== Much Better!

[source,python]
----
def factorize(n):
    """Find all prime factors of n.
    
    Args:
        n (int): number to factorize. Must be > 1.
    
    Returns:
        list of int: prime factors, smallest to largest.
    """
    # ... same algorithm with clear variable names
    factors = []
    # ... rest of code with comments
    return factors
----

[.notes]
--
Same algorithm, but now:
- Descriptive function name: `factorize`
- Descriptive variable name: `factors` instead of `fs`
- Comprehensive docstring explaining:
  - What the function does
  - What arguments it takes
  - What it returns
  - What exceptions it might raise

Comments explain non-obvious parts of the algorithm.

Good code is READ more often than it's WRITTEN. Invest in readability!
--

=== Docstrings

* Purpose of the function
* Arguments and their types
* Return value and type
* Exceptions that might be raised

[.notes]
--
A docstring is a string literal as the first statement in a function. Python recognizes it as documentation.

What to include:
1. One-line summary of what the function does
2. Blank line, then more detail if needed
3. Args section: each parameter, its type, what it means
4. Returns section: type and meaning of return value
5. Raises section: exceptions and when they're raised

Style: This is "Google style" docstrings. There are other styles (NumPy, Sphinx). Pick one and be consistent.

Tools like `help()` and documentation generators use docstrings. So do IDEs for autocomplete hints.

Minimum: Every function should have at least a one-line docstring saying what it does.
--

=== Functions: Summary

* Functions package reusable code
* Arguments: positional and keyword
* Parameters: required and optional
* Variables have scope (prefer local)
* Use `return`, not `print()`
* Write docstrings!

[.notes]
--
Transition: "What happens when something goes wrong? Let's talk about exceptions."
--

== Exceptions

When something goes wrong, an exception is raised

[.notes]
--
Exceptions are Python's way of signaling errors. When Python can't do what you asked, it raises an exception.

Without handling, exceptions crash your program. But you can catch them and handle them gracefully.

Different types of exceptions indicate different problems.
--

=== Common Exceptions

*IndexError* — index out of range

*KeyError* — dictionary key doesn't exist

*NameError* — variable/function not defined

*ValueError* — wrong value for operation

*ZeroDivisionError* — divided by zero

[.notes]
--
INDEXERROR: `my_list[100]` when list only has 5 items.

KEYERROR: `my_dict["missing"]` when key doesn't exist.

NAMEERROR: Using a variable before defining it, or typo in variable name.

VALUEERROR: `int("hello")` — "hello" isn't a valid integer.

ZERODIVISIONERROR: Exactly what it sounds like.

When you see these, the error message tells you the line number where it happened. Read the message carefully!
--

=== Stack Traces

image::call_stack01.svg[CallStack01]

[.notes]
--
When an exception occurs, Python shows you a "stack trace" (also called traceback).

The stack trace shows:
- Where the error actually occurred (bottom of the trace)
- How you got there (the chain of function calls)

Reading a stack trace:
1. Start at the BOTTOM — that's where the actual error is
2. Read the error type and message
3. Look at the line of code shown
4. If it's in your code, that's where to start debugging
5. If it's in library code, trace back UP to find your code that caused it

The "stack" is the call stack — the chain of function calls that are currently active.
--

=== Raising Exceptions

[source,python]
----
if response not in ['a', 'b', 'c']:
    raise ValueError("Response should be 'a', 'b', or 'c'")
----

[.notes]
--
Your code can raise exceptions too! Use this when the caller has done something wrong.

Pattern: `raise ExceptionType("descriptive message")`

Common exceptions to raise:
- ValueError: Argument has wrong value
- TypeError: Argument has wrong type
- RuntimeError: Something went wrong during execution

Always include a helpful error message. Future you will thank present you.

This is better than returning error codes or None — it forces the issue to be dealt with.
--

=== Handling Exceptions

[source,python]
----
try:
    number = int(response)
except ValueError:
    print("Not a valid integer")
else:
    return number
----

[.notes]
--
Use try/except to handle exceptions gracefully.

TRY: Code that might raise an exception.

EXCEPT: What to do if that specific exception occurs. You can have multiple except blocks for different exceptions.

ELSE (optional): Runs if NO exception occurred. Cleaner than putting code in the try block.

FINALLY (not shown): Runs whether or not an exception occurred. Good for cleanup like closing files.

Be specific about which exceptions you catch. Bare `except:` catches everything, including Ctrl+C, which makes your program hard to stop!
--

=== Exception Handling Example

[source,python]
----
def get_int():
    """ Ask for an integer until valid. """
    while True:
        response = input("Enter an integer: ")
        try:
            number = int(response)
        except ValueError:
            print("Invalid; try again")
        else:
            return number
----

[.notes]
--
This combines several concepts:
- `while True` for input validation
- `try/except` for handling invalid input
- `else` to return only on success

The flow:
1. Ask for input
2. Try to convert to int
3. If ValueError, print message, loop back
4. If no error, return the number (exits loop and function)

This is a very common pattern for robust input handling.

Note: We don't catch all exceptions—just ValueError. If something else goes wrong (like the user hits Ctrl+C), it should propagate up.
--

=== Exceptions: Summary

* Exceptions signal errors
* Stack traces help you debug
* `raise` to signal errors from your code
* `try/except` to handle errors gracefully

[.notes]
--
Final summary for the section.

Key takeaways:
1. Read error messages carefully — they tell you what went wrong and where
2. Stack traces read from bottom to top
3. Raise exceptions for caller errors
4. Handle exceptions you know how to recover from
5. Let unexpected exceptions propagate

That covers Python fundamentals! Questions?
--