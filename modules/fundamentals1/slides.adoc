= Into the weeds: Python fundamentals
:imagesdir: images
:docinfo: shared
:revealjsdir: https://cdn.jsdelivr.net/npm/reveal.js
:source-highlighter: highlightjs
:highlightjsdir: https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1
:highlightjs-theme: https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/base16/tomorrow-night.min.css
:customcss: ../../css/default.css
:revealjs_theme: white
:revealjs_width: 1400
:revealjs_height: 800
:revealjs_slideNumber: true
:revealjs_transition: slide
:revealjs_transitionSpeed: default
:title-slide-background-image: 1024px-In_the_corn_field.jpg

== Today's Goals

By the end of this session, you'll be able to:

* Distinguish between simple and compound statements
* Evaluate expressions and predict their results
* Trace variable assignments step by step
* Write conditional logic using `if`/`elif`/`else`
* Choose the right loop for different situations
* Define and call functions with confidence

[.notes]
--
Start with clear learning objectives so students know what to focus on. These are actionable and measurable.

Ask: "How many of you have written Python code before?" Get a sense of the room's experience level.
--

== Statements

A *statement* is a complete Python instruction

Think of it like a sentence in English‚Äîit expresses one complete thought.

[.notes]
--
Start by asking students: "What do you think makes up a Python program?" Guide them toward the idea that programs are made of instructions.

A statement is the fundamental building block of Python programs. Every line of code that does something is a statement. We'll see there are two main types: simple and compound.

Analogy: If a program is an essay, statements are the sentences.
--

=== Two Kinds of Statements

[cols="1,1", frame=none, grid=none]
|===
| *Simple* ‚Äî one instruction | *Compound* ‚Äî multiple statements

| Like a single sentence | Like a paragraph with multiple sentences
|===

[.notes]
--
Simple statements are single-line instructions that do one thing. Compound statements are more complex structures that contain other statements inside them.

Think of it like sentences vs. paragraphs. A simple statement is a sentence. A compound statement is a paragraph that contains multiple sentences working together.
--

=== Simple Statement Examples

[source,python]
x = 0                    # assignment

[source,python]
return True              # return from function

[source,python]
print("Hello")           # function call

[source,python]
continue                 # loop control

Each stands alone on its own line. Complete as-is.

[.notes]
--
Walk through each example:

1. `x = 0` ‚Äî This is an assignment statement. It creates a variable x and gives it the value 0.

2. `return True` ‚Äî This returns a value from a function. We'll cover functions later.

3. `print("Hello")` ‚Äî This calls the print function to display text.

4. `continue` ‚Äî Skips to the next iteration of a loop.

Each of these is complete on its own line. They don't need anything else to work.
--

=== üîÆ Predict: What's the Difference?

Look at these two code blocks. *Before running them*, predict: How are they different?

[cols="1,1", frame=none]
|===
a|
[source,python]
----
print("A")
print("B")
print("C")
----

a|
[source,python]
----
for letter in ["A", "B", "C"]:
    print(letter)
----
|===

[%step]
*Turn to a neighbor and discuss for 60 seconds.*

[.notes]
--
PRIMM "Predict" phase: Have students predict before explaining.

Give them 60 seconds to discuss with a neighbor. Walk around and listen to conversations.

After discussion, ask a few pairs to share their predictions. Don't correct yet‚Äîjust collect ideas.

Key insight we're building toward: The left has 3 simple statements. The right has 1 compound statement containing 1 simple statement that runs 3 times.
--

=== Compound Statements

[source,python]
----
for word in wordlist:
    print(word)
    first_letter = word[0]
----

[source,python]
----
if score >= 5:
    print("You win!")
else:
    print("Better luck next time.")
----

Notice: *colon* at end of header, *indented* body

[.notes]
--
Compound statements contain other statements inside them. Notice the colon at the end of the first line and the indentation of the lines that follow.

For the `for` loop: This iterates through a list of words. The two indented lines are the "body" of the loop‚Äîthey run for each word.

For the `if` statement: This checks a condition and runs different code depending on whether it's true or false.

Key observation: The body is always indented. This is how Python knows which statements belong inside the compound statement.
--

[.columns]
=== Anatomy of a Compound Statement

[.column]
image::anatomy_of_complex_statement.png[ComplexStatement, 500]

[.column]
[cols="1,3", frame=none, grid=none]
|===
| *CLAUSE* | A complete unit (if/elif/else each = one clause)
| *HEADER* | First line, ends with `:` (colon)
| *BODY* | Indented code belonging to the clause
|===

[.notes]
--
Point to each part of the diagram as you explain:

CLAUSE: A complete unit within a compound statement. An if/elif/else has multiple clauses.

HEADER: The first line of a clause. It always ends with a colon. Contains keywords like `if`, `for`, `while`, `def`, etc.

BODY: The indented code that belongs to a clause. Can contain simple statements, other compound statements, or both.

Critical rule: The body MUST be indented relative to the header. Python uses indentation to determine structure, unlike languages that use braces.

Common student mistake: Forgetting the colon at the end of the header. Python will give a syntax error.
--

=== Common Mistake: Missing Colon

[source,python]
----
if score >= 5    # ‚Üê Missing colon!
    print("You win!")
----

Python says: `SyntaxError: expected ':'`

*Every header line needs a colon at the end.*

[.notes]
--
This is one of the most common syntax errors for beginners. Python's error message is helpful here‚Äîit tells you exactly what's missing.

Tip: If you see "expected ':'" in an error, check the line above where the error points.
--

=== Statements: Summary

[cols="1,1", frame=none, grid=none]
|===
| A statement is... | a complete Python instruction
| Simple statements | individual instructions (one line)
| Compound statements | contain other statements (header + body)
| Bodies are always | *indented* under their header
|===

[.notes]
--
Quick recap before moving on. Ask students to give you an example of each type.

Transition: "Now let's look at what goes inside statements‚Äîexpressions."
--

== Expressions

An *expression* is code that evaluates to a value

[cols="1,1", frame=none, grid=none]
|===
| Statements | *do* something
| Expressions | *produce* something (a value)
|===

[.notes]
--
Key distinction: Statements DO something. Expressions PRODUCE something (a value).

Anywhere Python expects a value, you can put an expression. This is incredibly powerful‚Äîit means you can nest expressions inside other expressions.

Important: Any expression that stands alone on a line is also a statement (called an "expression statement").
--

=== üîÆ Predict: Which Are Expressions?

Which of these *produce a value*? (Think for 30 seconds)

[source,python]
----
5
x = 10
len("hello")
print("hi")
3 + 4 * 2
----

[%step]
*Turn to a neighbor and discuss for 60 seconds.*

[%step]
--
*Expressions:* `5`, `len("hello")`, `3 + 4 * 2`

*Not expressions:* `x = 10` (assignment statement)

*Tricky:* `print("hi")` is an expression that evaluates to `None`!
--

[.notes]
--
Give students 30 seconds to think, then reveal the answer.

Key insights:
- Literals like `5` are expressions (they evaluate to themselves)
- Function calls like `len("hello")` return values
- Math operations produce values
- Assignment is a STATEMENT, not an expression in Python
- print() technically returns None, but we rarely use that value
--

=== Common Expression Types

*Literals* ‚Äî values written directly in code
[source,python]
5    "hi"    True    3.14    [1, 2, 3]

*Variables* ‚Äî evaluate to their current value
[source,python]
x    username    total_score

*Function calls* ‚Äî run a function, evaluate to return value
[source,python]
abs(-4)    round(10.6)    len("hello")

[.notes]
--
LITERALS: These are values written directly in your code. The number 5 is an expression that evaluates to... 5. The string "hi" evaluates to the string "hi".

VARIABLES: When Python sees a variable name, it looks up the value and uses that. So if x equals 10, the expression `x` evaluates to 10.

FUNCTION CALLS: These run a function and evaluate to whatever the function returns. `abs(-4)` evaluates to 4. `round(10.6)` evaluates to 11.

You can combine these with operators to make more complex expressions.
--

=== Operators at a Glance

[cols="1,1,1", frame=none, grid=none]
|===
| *Arithmetic*
| *Comparison*
| *Logical*

| `+` `-` `*`
| `==` `!=`
| `not`

| `/` `//` `%`
| `>` `<`
| `and`

| `**`
| `>=` `\<=`
| `or`
|===

Also: `in` (membership), `is` (identity)

[.notes]
--
ARITHMETIC: Standard math operators. Note there are THREE division operators‚Äîwe'll cover those next.

COMPARISON: These compare values and return True or False. Double equals for equality (single equals is assignment!).

LOGICAL: For combining boolean values. `not` flips True/False. `and` requires both to be true. `or` requires at least one to be true.

MEMBERSHIP: `in` checks if something is inside a collection. Very useful for strings and lists.

IDENTITY: `is` checks if two things are the exact same object in memory. Different from `==` which checks if values are equal.
--

=== The Three Division Operators

[cols="1,2,2", frame=none]
|===
| Operator | What it does | Example

| `/`
| Floating-point (always decimal)
| `5 / 4` ‚Üí `1.25`

| `//`
| Floor division (rounds down)
| `5 // 4` ‚Üí `1`

| `%`
| Modulo (remainder)
| `5 % 4` ‚Üí `1`
|===

[%step]
--
üîÆ *Quick prediction:* Discuss with a neighbor: What do you think the results of `7 // 3` and `7 % 3` will be?
--

[.notes]
--
This trips up students constantly. Take time here.

FLOATING-POINT DIVISION (`/`): Always gives you a decimal result, even if it divides evenly. `4 / 2` gives `2.0`, not `2`.

FLOOR DIVISION (`//`): Rounds DOWN to the nearest integer. For positive numbers, it's like truncating. But `-5 // 4` is `-2`, not `-1`! It rounds toward negative infinity.

MODULO (`%`): Gives the remainder. Super useful for:
- Testing if a number is even: `x % 2 == 0`
- Wrapping around (like clock arithmetic)
- Extracting digits from numbers

Prediction answer: `7 // 3` is `2`, `7 % 3` is `1` (7 = 3*2 + 1)
--

=== Try It: Division Practice (2 min)

In your Python interpreter or notebook, predict then verify:

[source,python]
----
print(10 / 3)      # Predict: ___
print(10 // 3)     # Predict: ___
print(10 % 3)      # Predict: ___
print(-7 // 2)     # Predict: ___ (tricky!)
print(15 % 4)      # Predict: ___
----

*Check your predictions by running the code!*

[.notes]
--

Answers:
- 10 / 3 = 3.3333...
- 10 // 3 = 3
- 10 % 3 = 1
- -7 // 2 = -4 (floors toward negative infinity!)
- 15 % 4 = 3

The negative floor division surprises many students. Explain that // always rounds toward negative infinity, not toward zero.
--

=== Parentheses for Grouping

Just like algebra‚Äîforce operations to happen first

[source,python]
----
(3 + 4) * 2        # 14, not 11

(  3 * x**3        # Multi-line expressions
 + 4 * x**2        # inside parentheses
 - 2 * x           # are valid Python!
 + 1)
----

*When in doubt, add parentheses for clarity.*

[.notes]
--
Parentheses work exactly like in math class‚Äîthey force certain operations to happen first.

BONUS: A parenthesized expression can span multiple lines! This is really useful for long calculations or conditions. No backslashes needed.

This is cleaner than using backslashes for line continuation.

Operator precedence exists (PEMDAS-like), but when in doubt, use parentheses to make your intent clear.
--

=== Expressions: Summary

* Expressions *evaluate to values*
* Types: literals, variables, function calls
* Operators combine expressions
* Division: `/` (decimal) vs `//` (floor) vs `%` (remainder)
* Parentheses for grouping and multi-line

[.notes]
--
Transition: "Now that we know about expressions, let's talk about storing values in variables."
--

== Variables

Variables are *labels* (name tags) attached to values

[source,python]
----
name = "Gina"     # "name" is a label pointing to "Gina"
----


*Not boxes!* Multiple labels can point to the same value.

=== Important: Variables Are Labels, Not Boxes

In Python, variables are *labels* attached to values‚Äînot boxes storing data inside. 

[source,python]
----
a = [1, 2, 3]
b = a         # Both a and b point to the SAME list
a.append(4)
print(b)      # Output: [1, 2, 3, 4]
----

If you change the list using `a`, you'll see the change through `b`‚Äîbecause they point to the same value.

This is different from languages like C, where variables are actual memory locations (boxes holding values). In Python, variables are simply names attached to objects.

[.notes]
--
Important mental model: Variables in Python are NOT boxes; they're labels or name tags attached to values.

Multiple variables can point to the same value (object), so changing a mutable value through one variable affects all labels pointing to it.
--

=== Variable Naming Rules

[cols="1,1", frame=none]
|===
| ‚úÖ *Allowed* | ‚ùå *Not Allowed*

| Letters, numbers, underscores
| Starting with a number (`2fast`)

| `user_age`, `total_score`
| Keywords (`if`, `return`, `def`)

| lowercase with underscores (convention)
| Built-in names (`print`, `list`) ‚Äî *technically works but breaks the function!*
|===

[.notes]
--
CANNOT START WITH NUMBER: `2fast` is invalid, but `fast2` is fine.

KEYWORDS: Python reserves certain words. You'll get a syntax error if you try to use them as variable names.

FUNCTION NAMES: You CAN use these, but you'll break the function! If you do `print = 5`, you can no longer use the print function. Very common beginner mistake.

CONVENTION: Python uses `snake_case` for variables (lowercase with underscores). `CamelCase` is reserved for class names. Following conventions makes your code readable to other Python programmers.

Good names: `user_age`, `total_score`, `first_name`
Bad names: `x`, `data`, `temp` (unless truly temporary)
--

=== Common Mistake: Shadowing Built-ins

[source,python]
----
list = [1, 2, 3]           # DON'T DO THIS!
print = "Hello"            # Now print() is broken!

# Later...
list("hello")              # TypeError! list is now [1, 2, 3]
print("hi")                # TypeError! print is now "Hello"
----

*Avoid using names of built-in functions as variables.*

[.notes]
--
Demo this live if possible. Show that after `print = "Hello"`, calling print() gives an error.

List of common ones to avoid: list, str, int, float, dict, set, print, input, len, sum, max, min, type, id, range

If you accidentally do this, restart your Python session or use `del list` to remove your variable.
--

=== Variable Assignment

[.subgoal]
*Pattern:* `variable = expression`

Python evaluates the *right side first*, then attaches the label.

[source,python]
----
# Step 1: Evaluate right side ‚Üí "Gina"
# Step 2: Attach label "name" to that value
name = "Gina"

# Step 1: Evaluate width * height ‚Üí (some number)
# Step 2: Attach label "area" to that number
area = width * height

# Step 1: Call round(5.3) ‚Üí 5
# Step 2: Attach label "nearest_int" to 5
nearest_int = round(5.3)
----

[.notes]
--
The pattern: variable = expression

Python evaluates the RIGHT side first, then attaches the label to that value.

Example 1: Creates a string "Gina" and labels it `name`.

Example 2: Multiplies width by height, then labels the result `area`. Note: width and height must already exist!

Example 3: Calls round(5.3), which returns 5, then labels that 5 as `nearest_int`.

IMPORTANT: Assignment statements are NOT expressions. You cannot do `print(x = 5)` like in some other languages. (Python 3.8+ has the walrus operator `:=` for this, but that's advanced.)
--

=== üîÆ Predict: Variable Tracing

*Trace this code step by step.* What are the final values?

[source,python]
----
a = 5
b = a
a = 10
c = a + b
----

[%step]
--
[cols="1,1,1,1", frame=all]
|===
| Step | a | b | c

| `a = 5` | 5 | - | -
| `b = a` | 5 | 5 | -
| `a = 10` | 10 | 5 | -
| `c = a + b` | 10 | 5 | 15
|===

*Key insight:* `b = a` copies the *value*, not a link to `a`.
--

[.notes]
--
Have students trace on paper first (30 seconds), then reveal.

Critical point: When we do `b = a`, Python looks up the value of `a` (which is 5), and makes `b` point to that same value. Later changing `a` doesn't affect `b`‚Äîthey're independent labels.

This is true for immutable values (numbers, strings). Mutable values (lists) work differently‚Äîwe'll cover that in the next lecture.

Consider showing this in Python Tutor: https://pythontutor.com/
--

=== Augmented Assignment

Shorthand for "update based on current value"

[source,python]
----
# Instead of:          # Write:
x = x + 1              x += 1
total = total + price  total += price
count = count * 2      count *= 2
----

Available: `+=` `-=` `\*=` `/=` `//=` `%=` `*=`


[.notes]
--
This is syntactic sugar for a very common pattern: update a variable based on its current value.

`x += 1` means "take the current value of x, add 1, and store it back in x."

All the arithmetic operators have augmented versions. You'll use `+=` most often.

Common use cases:
- Counting: `count += 1`
- Accumulating sums: `total += price`
- Building strings: `message += " more text"`

Note: These are still statements, not expressions.
--

=== Try It: Variable Practice

Predict the output, then run to verify:

[source,python]
----
x = 7
y = x
x += 3
print(f"x = {x}, y = {y}")

name = "Pat"
name = name + "rick"
print(name)

counter = 0
counter += 1
counter += 1
counter *= 5
print(counter)
----

[.notes]
--
Give students 3 minutes. Walk around and check understanding.

Answers:
- x = 10, y = 7 (y still has original value)
- Patrick
- 10 (0 + 1 + 1 = 2, 2 * 5 = 10)

This reinforces that assignment creates a new binding, not a link.
--

=== Variables: Summary

* Variables are *labels* attached to values (not boxes!)
* Assignment: `variable = expression` (right side first)
* Augmented assignment: `+=`, `-=`, etc.
* Choose *descriptive names*, avoid built-in names

[.notes]
--
Transition: "Now let's talk about how to make decisions in our code."
--

== Conditional Statements

Making decisions in code

[source,python]
----
if temp <= 0:
    water_state = "ice"
elif temp <= 100:
    water_state = "water"
else:
    water_state = "steam"
----

Only *one branch* executes‚Äîthe first one that matches!

[.notes]
--
Conditional statements let your program make decisions.

Walk through the example: We're determining the state of water based on temperature (in Celsius).

- If temp is 0 or below ‚Üí ice
- Otherwise, if temp is 100 or below ‚Üí water
- Otherwise ‚Üí steam

Only ONE of these three branches will execute. Once a condition is true, Python runs that branch and skips the rest.
--

=== Structure

[cols="1,2", frame=none]
|===
| `if` | Required, comes first
| `elif` | "Else if" ‚Äî zero or more
| `else` | Catch-all ‚Äî zero or one, comes last
|===

[source,python]
----
if condition1:
    # runs if condition1 is True
elif condition2:
    # runs if condition1 is False AND condition2 is True
else:
    # runs if ALL above conditions are False
----

[.notes]
--
IF: Always required. Must have at least one `if`.

ELIF: "Else if" ‚Äî only checked if previous conditions were false. You can have as many as you need, or none at all.

ELSE: Catches everything that didn't match above. No condition needed‚Äîit's the default. Optional.

Critical point: At most ONE branch executes. As soon as Python finds a true condition, it runs that branch and skips checking the rest. This is why order matters!
--

=== üîÆ Predict: elif vs. Multiple if

[cols="1,1", frame=none]
|===
a|
[source,python]
----
# Version A: elif
temp = -10
if temp <= 0:
    state = "ice"
elif temp <= 100:
    state = "water"
print(state)
----

a|
[source,python]
----
# Version B: separate ifs
temp = -10
if temp <= 0:
    state = "ice"
if temp <= 100:
    state = "water"
print(state)
----
|===

*What does each version print? Discuss with a neighbor.*

[%step]
*Version A:* `ice` ‚úÖ ‚Äî *Version B:* `water` ‚ùå (both ifs run!)

[.notes]
--
This is a CRITICAL distinction that confuses students.

WITH ELIF: If temp is -10, the first condition is true, so state becomes "ice". The elif is SKIPPED because we already found a match. Final answer: "ice"

WITH SEPARATE IFS: If temp is -10, the first if is true, so state becomes "ice". But then Python checks the SECOND if independently. Is -10 <= 100? Yes! So state gets overwritten to "water". Final answer: "water" ‚Äî WRONG!

Rule: Use `elif` when conditions are mutually exclusive and you only want one to run. Use separate `if` statements when you want to check each condition independently.
--

=== Boolean Contexts: Truthy and Falsy

Conditions don't have to be True/False‚ÄîPython converts automatically.

[cols="1,1", frame=none]
|===
| *Falsy* (treated as False) | *Truthy* (everything else)

| `0`, `0.0`
| Any non-zero number

| `""` (empty string)
| Any non-empty string

| `[]`, `{}` (empty collections)
| Any non-empty collection

| `None`
| Most objects
|===

[source,python]
----
if my_list:          # True if list has items
    process(my_list)
----

[.notes]
--
When Python needs a True/False answer, it converts values automatically.

TRUTHY: Most things. Any non-zero number, any non-empty string, any non-empty list, etc.

FALSY (memorize these):
- Zero (integer 0 or float 0.0)
- Empty string ""
- Empty list []
- Empty dictionary {}
- None
- False (obviously)

This is useful! Instead of `if len(my_list) > 0:` you can just write `if my_list:`

Example:
```python
answer = input("Enter something: ")
if answer:    # True if they typed anything
    print("You entered:", answer)
else:
    print("You didn't enter anything")
```
--

=== Conditional Expressions (Ternary)

One-liner for simple if/else that *produces a value*

[source,python]
----
# Pattern: value_if_true if condition else value_if_false

status = "minor" if age < 18 else "adult"

# Equivalent to:
if age < 18:
    status = "minor"
else:
    status = "adult"
----

*Note: The `else` part is required!*

[.notes]
--
This is Python's ternary operator‚Äîa one-liner for simple if/else.

Pattern: `value_if_true if condition else value_if_false`

Read it as: "status equals 'minor' IF age is less than 18, ELSE 'adult'"

The else part is REQUIRED (unlike in conditional statements).

Use these for simple cases. If your logic is complex, use a regular if/else statement‚Äîreadability matters more than brevity.
--

=== Try It: Conditionals Practice (3 min)

Write code to assign `category` based on `score`:
- 90 or above ‚Üí "A"
- 80-89 ‚Üí "B"  
- 70-79 ‚Üí "C"
- Below 70 ‚Üí "F"

Test with `score = 85`. What should print?

[%step]
[source,python]
----
score = 85
if score >= 90:
    category = "A"
elif score >= 80:
    category = "B"
elif score >= 70:
    category = "C"
else:
    category = "F"
print(category)  # B
----

[.notes]
--
Give students 3 minutes. Walk around and help.

Common mistakes to watch for:
- Using separate `if` statements instead of `elif`
- Getting the order wrong (checking lower bounds first)
- Using `>` instead of `>=` for boundary cases

Ask: "What happens if score is exactly 80?"
--

=== Conditionals: Summary

* `if`/`elif`/`else` ‚Äî only one branch runs
* Order matters! First match wins
* Truthy/Falsy: most things are truthy
* Conditional expressions: `x if condition else y`

[.notes]
--
Transition: "What if we want to repeat code multiple times? That's where loops come in."
--

== Loops

Repeating instructions

[cols="1,1", frame=none]
|===
| `for` | When you know *what* to iterate over
| `while` | When you know *when* to stop
|===

[.notes]
--
Both types are compound statements with headers and bodies.

FOR loops: Use when you know how many times to iterate, or when you're iterating over a collection.

WHILE loops: Use when you need to repeat until some condition changes, and you don't know in advance when that will be.
--

=== `for` Loop Anatomy

[source,python]
----
for item in collection:
    # body: do something with item
----

[source,python]
----
# Example: sum numbers 1-10
total = 0
for i in range(1, 11):
    total += i
print(total)  # 55
----

*The variable `i` takes each value from the range in turn.*

[.notes]
--
Pattern: `for variable in iterable:`

ITERABLE: Something you can iterate over‚Äîa list, string, range, file, etc.

ITERATION VARIABLE: Created by the for loop. Takes on each value from the iterable in turn. In this example, i will be 1, then 2, then 3... up to 10.

Note: `range(1, 11)` gives you 1 through 10. The end value is exclusive! This trips up students.

The body runs once for each item. Here we're calculating the sum of 1 through 10.
--

=== üîÆ Predict: What Does range() Produce?

[source,python]
----
list(range(5))          # [_______________]
list(range(2, 6))       # [_______________]
list(range(0, 10, 2))   # [_______________]
list(range(10, 0, -1))  # [_______________]
----

[%step]
--
[source,python]
----
list(range(5))          # [0, 1, 2, 3, 4]
list(range(2, 6))       # [2, 3, 4, 5]
list(range(0, 10, 2))   # [0, 2, 4, 6, 8]
list(range(10, 0, -1))  # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
----

*Remember: End value is EXCLUDED. range(5) gives 0-4, not 0-5!*
--

[.notes]
--
Have students predict, then reveal.

Key points:
- range(n) gives 0 to n-1
- range(start, stop) gives start to stop-1
- range(start, stop, step) lets you skip or go backwards
- The stop value is NEVER included

This "exclusive end" matches how slicing works and how counting works in computer science.
--

=== `while` Loop Anatomy

[source,python]
----
while condition:
    # body: runs as long as condition is True
----

[source,python]
----
# Example: find first power of 3 over 1000
n = 1
while n <= 1000:
    n *= 3
print(n)  # 2187
----

*‚ö†Ô∏è Danger: If condition never becomes False ‚Üí infinite loop!*

[.notes]
--
Pattern: `while condition:`

The loop keeps running AS LONG AS the condition is true. When it becomes false, the loop ends.

DANGER: If the condition never becomes false, you have an infinite loop! Always make sure something in the body can change the condition.

This example finds the first power of 3 greater than 1000. We start at 1 and keep multiplying by 3 until we exceed 1000.

Trace through: n=1, n=3, n=9, n=27, n=81, n=243, n=729, n=2187 (stops here because 2187 > 1000).

Use while when:
- Waiting for user to enter valid input
- Reading until end of file
- Searching for something
- Any situation where you don't know the count beforehand
--

=== Pattern: `while True` for Input Validation

[source,python]
----
while True:
    response = input("Enter 'a' or 'b': ")
    if response in ['a', 'b']:
        break  # Exit the loop
    print("Invalid choice. Try again.")
----

*Guarantees at least one iteration. Must have `break` or `return` inside!*

[.notes]
--
`while True` creates an intentionally infinite loop. You MUST have a `break` or `return` inside to exit!

Why use it? When you want the body to run AT LEAST ONCE before checking a condition.

This pattern is called a "do-while" in other languages. Python doesn't have do-while, so we use `while True` with a break/return.

Perfect for input validation: Ask for input, check if it's valid, break if yes, otherwise show error and ask again.

Common mistake: Forgetting the exit condition and creating an actual infinite loop. Always have a clear path out!
--

=== Loop Control: break, continue, return

[cols="1,2", frame=none]
|===
| `continue` | Skip to next iteration
| `break` | Exit the loop entirely
| `return` | Exit loop AND function
|===

[source,python]
----
for line in file:
    line = line.strip()
    if line.startswith("#"):
        continue       # Skip comments
    if line == "END":
        break          # Stop reading
    process(line)
----

[.notes]
--
CONTINUE: Stops the current iteration and jumps back to the top of the loop. For `for` loops, moves to the next item. For `while` loops, re-checks the condition.

BREAK: Immediately exits the loop. Code continues after the loop.

RETURN: Exits both the loop AND the function it's in. Only works inside functions.

Use cases:
- Continue: Skip items that don't meet criteria
- Break: Found what you're looking for, no need to keep searching
- Return: Ready to give back a result
--

=== Try It: Loop Practice

Write a loop that prints all *even* numbers from 1 to 20.

*Two approaches‚Äîtry both!*

[%step]
[source,python]
----
# Approach 1: Check each number
for i in range(1, 21):
    if i % 2 == 0:
        print(i)

# Approach 2: Generate only evens
for i in range(2, 21, 2):
    print(i)
----

[.notes]
--
Give students 4 minutes. Encourage them to try both approaches.

Discuss tradeoffs:
- Approach 1 is more explicit about the logic
- Approach 2 is more efficient (fewer iterations)
- Both are valid; context determines which is better

Extension: How would you print only odd numbers?
--

=== Loops: Summary

* `for` ‚Äî iterate over a collection/range
* `while` ‚Äî repeat until condition is false
* `while True` ‚Äî at least one iteration (needs `break`)
* Control: `continue` (skip), `break` (exit), `return` (exit all)

[.notes]
--
Transition: "Now let's package our code into reusable units‚Äîfunctions."
--

== Functions

Reusable blocks of code with a name

[cols="1,1", frame=none]
|===
| *Input* | Arguments (what you pass in)
| *Output* | Return value (what you get back)
|===

[source,python]
----
def greet(name):
    return f"Hello, {name}!"

message = greet("Alice")  # "Hello, Alice!"
----

[.notes]
--
Functions are the fundamental unit of code organization. They let you:
- Write code once, use it many times
- Break complex problems into smaller pieces
- Test pieces independently
- Make code readable by giving names to operations

Think of a function like a machine: you put things in (arguments), something happens inside, and you get something out (return value).
--

=== Why Write Functions?

* *Reuse* ‚Äî Write once, use many times
* *Organization* ‚Äî Break problems into steps
* *Readability* ‚Äî `calculate_tax(income)` > 20 lines of math
* *Testing* ‚Äî Test small pieces in isolation

[source,python]
----
# Without function: hard to read
result = ((income - deductions) * rate) - credits

# With function: clear intent
result = calculate_tax(income, deductions, rate, credits)
----

[.notes]
--
Functions are not just about avoiding repetition (though that's important).

PROBLEM DECOMPOSITION: Complex problems become manageable when broken into small functions.

READABILITY: `calculate_tax(income)` is clearer than 20 lines of tax calculation inline.

TESTING: You can test small functions in isolation. If each function works, the whole program is more likely to work.

REUSE: Write once, use many times. Even use in other projects.

Rule of thumb: If you're copying and pasting code, you probably need a function.
--

=== Built-in Functions You Already Know

[cols="1,2", frame=none]
|===
| `print(x)` | Display x (returns `None`)
| `len(x)` | Length of x
| `abs(x)` | Absolute value
| `round(x)` | Round to integer
| `int(x)`, `float(x)`, `str(x)` | Type conversion
| `input(prompt)` | Get user input (returns string)
| `range(start, stop, step)` | Generate number sequence
|===

[.notes]
--
Python comes with many built-in functions. These are always available.

PRINT: Display to console. Returns None.

ABS: Absolute value. `abs(-5)` returns `5`.

ROUND: Round to nearest integer (or specified decimals). `round(3.7)` returns `4`. `round(3.14159, 2)` returns `3.14`.

TYPE CONVERSIONS:
- `int("42")` returns `42`
- `float("3.14")` returns `3.14`
- `str(42)` returns `"42"`

These will raise errors if the conversion isn't possible: `int("hello")` raises ValueError.
--

=== Calling Functions

[source,python]
----
print()                  # No arguments
x = abs(-10)             # One argument
n = round(14.723, 2)     # Two arguments
----

*Every call needs parentheses, even with no arguments!*

Positional vs. Keyword Arguments:
[source,python]
----
print("Hello", "world", sep="::", end="!\n")
#     ‚Üë‚Üë‚Üë positional ‚Üë‚Üë‚Üë   ‚Üë‚Üë‚Üë keyword ‚Üë‚Üë‚Üë
----

[.notes]
--
Every function call has parentheses, even if there are no arguments.

The value inside the parentheses (the argument) can be any expression. So `abs(-10)` works, but so does `abs(x)` or `abs(y - z)`.

Function calls ARE expressions‚Äîthey evaluate to the return value. That's why we can assign `abs(-10)` to `x`.

If a function doesn't explicitly return something, it returns `None`.

POSITIONAL: Matched to parameters by position (first argument to first parameter, etc.). Order matters!

KEYWORD: Matched by name. Order doesn't matter among keyword arguments.

Rules:
1. Positional arguments must come BEFORE keyword arguments
2. You can't have positional arguments after keyword arguments
--

=== Defining Functions

[.subgoal]
*Subgoals:* 1) Name it 2) Define parameters 3) Write body 4) Return result

[source,python]
----
def calculate_area(width, height):
    """Calculate the area of a rectangle.
    
    Args:
        width: The width of the rectangle
        height: The height of the rectangle
    
    Returns:
        The area (width √ó height)
    """
    area = width * height
    return area
----

[.notes]
--
Pattern: `def function_name(parameters):`

DEF: Keyword that starts a function definition.

FUNCTION NAME: Same rules as variable names. Should describe what the function does.

PARAMETERS: Variables that receive the arguments. Separated by commas if multiple.

DOCSTRING: A string right after the header that describes the function. Triple quotes for multi-line. This is documentation!

BODY: The code that runs when the function is called.

RETURN: Specifies what value the function evaluates to. If you don't return anything (or just `return` with no value), the function returns `None`.
--

=== üö® Critical: `return` vs. `print()`

[cols="1,1", frame=none]
|===
| `return` | `print()`

| Sends value *back to caller*
| Displays text *to human*

| Value can be used in code
| Value is gone (returns `None`)

| Function ends
| Function continues
|===

[source,python]
----
def bad_add(a, b):
    print(a + b)       # Shows "7" but returns None!

def good_add(a, b):
    return a + b       # Returns 7, can be used

result = bad_add(3, 4)   # result = None ‚ùå
result = good_add(3, 4)  # result = 7 ‚úÖ
----

[.notes]
--
Students confuse these constantly!

RETURN:
- Sends a value back to the calling code
- The function call expression equals this value
- You can use the returned value in further calculations
- Nothing visible happens on screen

PRINT:
- Displays text on the console
- Returns None
- The displayed text cannot be used by your program
- Only for human eyes

Rule: Functions should RETURN results. Print them separately if needed.

Mantra from Runestone Academy: "Print is for people, return is for code."
--

=== üîÆ Predict: return vs. print

[source,python]
----
def version_a(x):
    print(x * 2)

def version_b(x):
    return x * 2

result_a = version_a(5)
result_b = version_b(5)

print(f"result_a = {result_a}")
print(f"result_b = {result_b}")
----

*What gets printed? What are the final values?*

[%step]
--
[source,python]
----
10              # from version_a's print
result_a = None # version_a returned None!
result_b = 10   # version_b returned 10
----
--

[.notes]
--
Walk through step by step:
1. version_a(5) prints "10" to screen, returns None
2. result_a gets None
3. version_b(5) returns 10, prints nothing
4. result_b gets 10
5. We print both results

The key insight: version_a LOOKED like it worked because we saw "10", but the value was lost. We couldn't do math with it later.
--

=== Variable Scope

*Scope* = where a variable can be accessed

[cols="1,1", frame=none]
|===
| *Local* (inside function) | *Global* (outside function)

| Created when function runs
| Created at top level

| Destroyed when function ends
| Exists for entire program

| *Preferred!* Self-contained.
| Can cause subtle bugs.
|===

[source,python]
----
x = 10          # Global

def my_func():
    y = 5       # Local - only exists inside my_func
    return y

print(y)        # NameError! y doesn't exist here
----

[.notes]
--
SCOPE: Where a variable can be accessed.

GLOBAL VARIABLES: Defined at the top level of your script. Can be read anywhere. But modifying them from inside a function requires the `global` keyword.

Problems with globals:
- Functions aren't self-contained
- Hard to track what's changing the variable
- Leads to subtle bugs

LOCAL VARIABLES: Defined inside a function (including parameters). Created when function runs, destroyed when function ends.

Benefits of locals:
- Function is self-contained
- No outside interference
- Easier to test and debug

Best practice: Pass values IN through parameters, get values OUT through return. Avoid globals.
--

=== Required vs. Optional Parameters

[source,python]
----
def greet(name, greeting="Hello", punctuation="!"):
    """Greet someone with optional customization."""
    return f"{greeting}, {name}{punctuation}"

# Using defaults:
greet("Alice")                    # "Hello, Alice!"

# Overriding one default:
greet("Bob", greeting="Hi")       # "Hi, Bob!"

# Overriding both:
greet("Carol", "Hey", "...")      # "Hey, Carol..."
----

*Required parameters first, optional (with defaults) last.*

[.notes]
--
REQUIRED: Just a name. Must be provided when calling. Here: `name`.

OPTIONAL: Have a default value using `=`. Can be omitted when calling. Here: `greeting` and `punctuation`.

Rules:
- Required parameters must come BEFORE optional parameters
- Avoid mutable defaults like lists or dictionaries (they're shared between calls!)

This gives callers flexibility‚Äîthey can use simple defaults or customize as needed.
--

=== Docstrings: Document Your Functions

[source,python]
----
def calculate_bmi(weight_kg, height_m):
    """Calculate Body Mass Index.
    
    Args:
        weight_kg: Weight in kilograms
        height_m: Height in meters
    
    Returns:
        BMI as a float (weight / height¬≤)
    
    Raises:
        ValueError: If height is zero or negative
    """
    if height_m <= 0:
        raise ValueError("Height must be positive")
    return weight_kg / (height_m ** 2)
----

[.notes]
--
A docstring is a string literal as the first statement in a function. Python recognizes it as documentation.

What to include:
1. One-line summary of what the function does
2. Blank line, then more detail if needed
3. Args section: each parameter, its type, what it means
4. Returns section: type and meaning of return value
5. Raises section: exceptions and when they're raised

Style: This is "Google style" docstrings. There are other styles (NumPy, Sphinx). Pick one and be consistent.

Tools like `help()` and documentation generators use docstrings. So do IDEs for autocomplete hints.

Minimum: Every function should have at least a one-line docstring saying what it does.
--

=== Try It: Write a Function (5 min)

Write a function `is_even(n)` that:
- Takes an integer `n`
- Returns `True` if `n` is even, `False` otherwise
- Include a docstring

Test cases:
[source,python]
----
print(is_even(4))   # True
print(is_even(7))   # False
print(is_even(0))   # True
----

[%step]
[source,python]
----
def is_even(n):
    """Return True if n is even, False otherwise."""
    return n % 2 == 0
----

[.notes]
--
Give students 5 minutes. Walk around and help.

Common mistakes:
- Using print instead of return
- Writing `if n % 2 == 0: return True else: return False` (works but verbose)
- Forgetting the docstring

The elegant solution uses the fact that `n % 2 == 0` is already a boolean expression.

Ask fast finishers: Can you write `is_odd(n)` in terms of `is_even(n)`?
--

=== Functions: Summary

* Functions package reusable code
* `return` sends values back (not `print`!)
* Parameters can be required or optional (with defaults)
* Variables have scope‚Äîprefer local over global
* Always write docstrings

[.notes]
--
Transition: "What happens when something goes wrong? Let's talk about exceptions."
--

== Exceptions

When something goes wrong, Python *raises* an exception

[source,python]
----
>>> int("hello")
ValueError: invalid literal for int()

>>> my_list[100]
IndexError: list index out of range

>>> print(undefined_variable)
NameError: name 'undefined_variable' is not defined
----

[.notes]
--
Exceptions are Python's way of signaling errors. When Python can't do what you asked, it raises an exception.

Without handling, exceptions crash your program. But you can catch them and handle them gracefully.

Different types of exceptions indicate different problems.
--

=== Common Exception Types

[cols="1,2", frame=none]
|===
| `IndexError` | Index out of range
| `KeyError` | Dictionary key doesn't exist
| `NameError` | Variable/function not defined
| `ValueError` | Wrong value for operation
| `TypeError` | Wrong type for operation
| `ZeroDivisionError` | Divided by zero
| `FileNotFoundError` | File doesn't exist
|===

[.notes]
--
INDEXERROR: `my_list[100]` when list only has 5 items.

KEYERROR: `my_dict["missing"]` when key doesn't exist.

NAMEERROR: Using a variable before defining it, or typo in variable name.

VALUEERROR: `int("hello")` ‚Äî "hello" isn't a valid integer.

TYPEERROR: `"hello" + 5` ‚Äî can't add string and int.

ZERODIVISIONERROR: Exactly what it sounds like.

When you see these, the error message tells you the line number where it happened. Read the message carefully!
--

=== Raising Exceptions

Signal errors in your own code:

[source,python]
----
def divide(a, b):
    """Divide a by b."""
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b
----

*Pattern:* `raise ExceptionType("descriptive message")`

[.notes]
--
Your code can raise exceptions too! Use this when the caller has done something wrong.

Pattern: `raise ExceptionType("descriptive message")`

Common exceptions to raise:

- ValueError: Argument has wrong value
- TypeError: Argument has wrong type
- RuntimeError: Something went wrong during execution

Always include a helpful error message. Future you will thank present you.

This is better than returning error codes or None ‚Äî it forces the issue to be dealt with.
--

=== Handling Exceptions with try/except

[source,python]
----
try:
    number = int(user_input)
except ValueError:
    print("That's not a valid number!")
else:
    print(f"You entered {number}")
finally:
    print("Thanks for playing!")  # Always runs
----

[cols="1,2", frame=none]
|===
| `try` | Code that might fail
| `except` | What to do if it fails
| `else` | Runs if no exception (optional)
| `finally` | Always runs (optional)
|===

[.notes]
--
Use try/except to handle exceptions gracefully.

TRY: Code that might raise an exception.

EXCEPT: What to do if that specific exception occurs. You can have multiple except blocks for different exceptions.

ELSE (optional): Runs if NO exception occurred. Cleaner than putting code in the try block.

FINALLY (not shown): Runs whether or not an exception occurred. Good for cleanup like closing files.

Be specific about which exceptions you catch. Bare `except:` catches everything, including Ctrl+C, which makes your program hard to stop!
--

=== Pattern: Input Validation Loop

[source,python]
----
def get_integer(prompt):
    """Keep asking until user enters a valid integer."""
    while True:
        try:
            return int(input(prompt))
        except ValueError:
            print("Please enter a valid integer.")

age = get_integer("Enter your age: ")
----

[.notes]
--
This combines several concepts:
- `while True` for input validation
- `try/except` for handling invalid input
- `return` to exit on success

The flow:
1. Ask for input
2. Try to convert to int
3. If ValueError, print message, loop back
4. If no error, return the number (exits loop and function)

This is a very common pattern for robust input handling.

Note: We don't catch all exceptions‚Äîjust ValueError. If something else goes wrong (like the user hits Ctrl+C), it should propagate up.
--

=== Try It: Exception Handling

Write a function `safe_divide(a, b)` that:
- Returns `a / b` if possible
- Returns `None` if `b` is zero
- Prints a warning when division by zero is attempted

[source,python]
----
print(safe_divide(10, 2))   # 5.0
print(safe_divide(10, 0))   # Warning! ‚Üí None
----

[%step]
[source,python]
----
def safe_divide(a, b):
    """Safely divide a by b, returning None if b is zero."""
    try:
        return a / b
    except ZeroDivisionError:
        print("Warning: Cannot divide by zero")
        return None
----

[.notes]
--
Give students 4 minutes

Alternative solution using if statement:
```python
def safe_divide(a, b):
    if b == 0:
        print("Warning: Cannot divide by zero")
        return None
    return a / b
```

Both are valid. The try/except version is more "Pythonic" (ask forgiveness, not permission). The if version is more explicit.
--

=== Exceptions: Summary

* Exceptions signal errors to the caller
* Stack traces: read bottom to top
* `raise` to signal errors from your code
* `try/except` to handle errors gracefully
* Be specific about which exceptions to catch

== üìã Key Takeaways

[cols="1,1", frame=none]
|===
| Statements | Complete instructions (simple or compound)
| Expressions | Code that produces a value
| Variables | Labels pointing to values
| Conditionals | `if`/`elif`/`else` ‚Äî one branch runs
| Loops | `for` (collections) / `while` (conditions)
| Functions | Reusable code ‚Äî use `return`, not `print`!
| Exceptions | Handle errors gracefully with `try`/`except`
|===

== Practice Challenge

Write a function `letter_grade(score)` that:

- Takes a numeric score (0-100)
- Returns the letter grade ("A", "B", "C", "D", "F")
- Raises `ValueError` if score is out of range
- Includes a proper docstring

*Work with a partner. Test thoroughly!*

[.notes]
--
This is an integrative exercise that combines:
- Functions
- Conditionals
- Exception raising
- Docstrings

Give 10+ minutes for this one. Walk around and help.

Sample solution in next slide (hidden or show at end).
--

=== Practice Challenge: Solution

[source,python]
----
def letter_grade(score):
    """Convert numeric score to letter grade.
    
    Args:
        score: Numeric grade (0-100)
    
    Returns:
        Letter grade as string ("A", "B", "C", "D", or "F")
    
    Raises:
        ValueError: If score is not between 0 and 100
    """
    if score < 0 or score > 100:
        raise ValueError(f"Score must be 0-100, got {score}")
    
    if score >= 90:
        return "A"
    elif score >= 80:
        return "B"
    elif score >= 70:
        return "C"
    elif score >= 60:
        return "D"
    else:
        return "F"
----

== Questions?

üîó *Resources:*

* Python Tutor: https://pythontutor.com/python-compiler.html#mode=edit (visualize execution)
* Official Python Tutorial: https://docs.python.org/3/tutorial/
